# 05. 구성 단위
- 병렬 프로그램을 작성할 때 필요한 동기화 기법과 디자인 패턴에 대해 알아본다.

## 5.1 동기화된 컬렉션 클래스
- 동기화된 컬렉션 클래스: Vector, Hashtable, Collections.synchronizedXxx 메소드
- 동기화된 컬렉션 클래스는 모든 메소드(public)를 캡슐화하여 한 스레드만 사용할 수 있도록 제어하여 스레드 안정성을 확보
- 클라이언트 측 락 기법을 적용할 수 있다.
- 동기화 기법을 내부에 캡슐화하면 동기화 정책을 적용하기 쉽다.

### 5.1.1 동기화된 컬렉션 클래스의 문제점
- 스레드 안정성을 확보하였지만, 여러 스레드가 하나의 컬렉션을 사용할 경우 올바르게 동작하지 않을 수 있다.

### 5.1.2 Iterator와 ConcurrentModificationException
- Iterator는 Collection 클래스의 값을 차례로 반복시키는 표준 방법이다.
- 반복문 실행 도중 다른 스레드가 컬렉션 내부 값을 변경할 때, 즉시 멈춤(Fail-Fast) 형태로 동작
    - 즉시 멈춤(Fail-Fast)
        - 반복문을 실행하는 도중에 컬렉션 클래스 내부 값을 변경하는 상황이 포착되는 즉시 ConcurrentModificationException 예외를 발생시킨다.
        - 변경하는 상황을 포착하기 위하여 변경 횟수를 확인하는 부분이 적절한 동기화가 없기 때문에 스테일 값을 사용할 가능성이 있다. 
- 반복문 실행시 적절한 락을 이용해 동기화 해야 한다.
- 예외적으로 Iterator를 통하지 않고 컬렉션을 직접 수정할경우 단일 스레드 환경에서도 ConcurrentModificationException 예외가 발생할 수 있다.
- 반복문에서 락을 잡고 있는 상황에서 반복문 내부 로직에서 또 다른 락을 확보해야 한다면, 데드락(Deadlock)이 발생할 가능성이 있다.
    - clone 메소드를 통해 특정 스레드에 한정된 복사본을 만들어 복사본을 대상으로 반복문 사용하여 해결이 가능하다.

### 5.1.3 숨겨진 Iterator
- Iterator 사용이 메소드 내부로 숨겨져 있는 경우가 있다.
- 숨겨진 Iterator를 사용하는 모든 메소드에서 ConcurrentModificationException 예외가 발생할 수 있다.

## 5.2 병렬 컬렉션
- 동기화 컬렉션 클래스를 병렬 컬렉션으로 교체하여 성능을 향상 시킬 수 있다.
- 병렬 컬렉션은 여러 스레드에서 동시에 사용할 수 있도록 설계되었다.
    - ConcurrentHashMap: HashMap 클래스의 병렬성 확보 
    - CopyOnWriteArrayList: List 클래스의 반복 열람 연산 성능을 최우선으로 구현한 하위 클래스
    - ConcurrentMap: 없는 경우 추가하는 (Put-If-Absent) 연산, 대치(Replace) 연산, 조건부 제거(Conditional Remove) 연산 등을 추가로 정의한 인터페이스
    - Queue
        - ConcurrentLinkedQueue: 전통적인 FIFO(First-In, First-Out) 큐
        - PriorityQueue: 특정 우선 순위에 따라 큐에 쌓인 항목을 추출하는 큐
        - BlockingQueue: 상황에 따라 대기하는 큐로 프로튜서-컨슈머(Producer-Consumer) 구조에 적합
    - ConcurrentSkipListMap: SortedMap 클래스의 병렬성 확보 (SortedMap: TreeMap을 synchronizedMap으로 동기화한 컬렉션)
    - ConcurrentSkipListSet: SortedSet 클래스의 병렬성 확보 (SortedSet: TreeSet을 synchronizedMap으로 동기화한 컬렉션)

### 5.2.1 ConcurrentHashMap
- 락 스트라이핑(Lock Striping) 동기화 방법을 사용하여 여러 스레드에서 공유할 수 있다. (이전에는 모든 연산이 동일한 락을 사용하여 단일 스레드만 해당 컬렉션을 사용할 수 있었다.)
- 해시 연산은 담고있는 객체들의 hashCode 값이 넓게 분포되어 있지 않으면 훨씬 많은 연산이 필요하다.
- 반복문 작업과 동시에 값이 변경 될 경우 미약한 일관성 전략을 취한다.
    - 미약한 일관성 전략은 반복문과 동시에 값이 변경되어도 Iterator가 만들어진 시점으로 반복을 계속한다.
    - ConcurrentModificationException 예외가 발생하지 않는다.

### 5.2.2 Map 기반의 또 다른 단일 연산
- ConcurrentHashMap은 락을 독점할 수 없어 클라이언트 측 락 기법을 적용할 수 없다.
- 여러 개의 연산을 모아 새로운 단일 연산을 만들고자 할때 ConcurrentHashMap 보다 ConcurrentMap을 사용하여 구현해야 한다.

### 5.2.3 CopyOnWriteArrayList
- List 클래스의 병렬성 확보
- 비슷하게 동작하는 CopyOnWriteArraySet도 있다.
- 변경할 때마다 복사본을 이용하여 연산하기 때문에 동시 사용성에 문제가 발생하지 않는다.
- ConcurrentModificationException 예외가 발생하지 않는다.
- 변경이 잦으면 성능 문제가 발생할 수 있어 변경보다 반복문이 빈번한 경우 사용하기 적절하다.

## 5.3 블로킹 큐와 프로듀서-컨슈머 패턴
- 블로킹 큐
    - 프로듀서-컨슈머(Producer-Consumer) 패턴을 구현할 때 사용하기 유용하다.
    - 처리할 수 있는 양보다 많은 작업량을 처리할 수 있다.
    - 블로킹 큐(BlockingQueue) 인터페이스를 제공한다.
        - LinkedBlockingQueue, ArrayBlockingQueue: FIFO 큐
        - PriorityBlockingQueue: 우선 순위를 갖는 큐 (Comparable, Comparator를 사용해 정렬이 가능)
        - SynchronousQueue: 큐 내부에 값을 갖지 않고 큐를 사용하려는 스레드를 관리하는 목적의 블로킹 큐
- put, take, offer, poll 메소드 제공
    - put: 값을 추가할 공간이 있을때까지 대기하고 값을 추가
    - take: 가져올 값이 있을때까지 대기하고 값을 가져옴
    - offer: 값을 추가할 공간이 없으면 오류를 발생하고 있으면 값을 추가
    - poll: 가져올 값이 있으면 값을 가져옴
- 프로튜서-컨슈머 패턴
    - 작업을 만드는 주체와 작업을 처리하는 주체를 분리하여 부하를 조절
    
### 5.3.1 예제: 데스크탑 검색
- 프로듀서: 디렉토리 계층 구조를 따라가면서 검색 대상 파일을 큐에 쌓음
- 컨슈머: 대상 파일을 색인
- 프로듀서-컨슈머로 분리시 코드 가독성, 재사용성이 높아진다.
- 블로킹 큐를 통해 프로듀서-컨슈머 클래스 간의 작업 흐름을 조절한다.
- Executor는 내부적으로 프로듀서-컨슈머 패턴 사용한다.

### 5.3.2 직렬 스레드 한정
- java.util.concurrent 패키지의 블로킹 큐 클래스는 모두 프로듀서에서 컨슈머로 객체를 넘겨줄 때 동기화 기법이 적용되어 있다.
- 직렬 스레드 한정(Serial Thread Confinement)
    - 객체를 안전하게 공개하면 객체에 대한 소유권을 이전(Transfer)할 수 있다.
    - 소유권이 이전된 객체는 소유권을 갖고 있는 스레드만이 객체의 상태를 알 수 있다.
- 객체 풀(Object Pool)은 풀에서 소유하고 있는 객체를 외부 스레드에게 빌려주는 역할을 수행한다.
    
### 5.3.3 덱, 작업 가로채기
- JDK 1.6+ 부터 Deque, BlockingDeque 컬렉션이 추가되었다.
- Deque는 앞과 뒤 어느 쪽에도 객체를 쉽게 삽입하거나 제거할 수 있다.
- 작업 가로채기(Work Stealing) 패턴 적용할 때에는 덱을 사용할 수 있다.
- 작업 가로채기(Work Stealing): 모든 컨슈머가 각자의 덱을 갖고, 자신의 덱 작업이 끝나면 다른 컨슈머에 쌓여있는 덱의 맨 뒤 작업을 가로채 처리하는 것을 말한다.
- 프로듀서-컨슈머 패턴처럼 하나의 큐를 갖고 작업하는 것이 아니기 때문에 서로 경쟁하지 않는다. 
- 대규모 시스템을 구현하기 적합하다.
- 작업 가로채기 패턴은 또한 컨슈머가 프로듀서의 역할도 갖고 있는 경우 적용하기 좋다.
- 스레드가 작업을 진행하는 도중에 새로 처리해야 할 작업이 생기면 자신의 덱에 새로운 작업을 추가한다.

## 5.4 블로킹 메소드, 인터럽터블 메소드
- 스레드가 블록되면 동작이 멈춰진 다음 블록된 상태(BLOCKED, WAITING, TIMED_WAITING) 중 하나의 상태를 갖는다.
- 외부 신호가 확인되면 상태가 다시 RUNNABLE 상태로 넘어간다.
- 블로킹 메소드는 InterruptedException을 발생시킬 수 있다.
- Thread 클래스는 해당 스레드를 중단시킬 수 있도록 interrupt 메소드를 제공한다.
- InterruptedException 예외가 발생할 경우 
    - InterruptedException 전달: 호출한 메소드로 예외를 넘기거나, catch 하지 않는 방법
    - 인터럽트를 무시하고 복구: 예외를 넘길 수 없는 경우(Runnable 인터페이스를 구현한 경우) 상위 호출 메소드가 인터럽트 상황이 발생했을을 알 수 있도록 현재 스레드의 interrupt 메소드를 호출
- InterruptedException 처리시 예외를 무시하는 것은 절대로 해서는 안된다.
    - 호출 스택의 상위 메소드가 인터럽트에 대응해 조치를 취할 수 있는 기회를 주지 않는다.
    - Thread를 직접 상속하는 경우는 예외를 더 이상 전파하지 않을 수 있는 경우이므로 예외로 한다.
    
## 5.5 동기화 클래스
- 스레드 간의 작업 흐름을 조절할 수 있도록 만들어진 모든 클래스를 동기화 클래스(Synchronizer)라고 한다.
- 세마포어(Semaphore), 배리어(Barrier), 래치(Latch) 등이 있다.
- 동기화 클래스는 모두 대기 상태를 결정하는 상태 정보를 갖고, 그 상태를 변경할 수 있는 메소드를 제공한다.

### 5.5.1 래치
- 래치는 터미널(Terminal) 상태에 이를 떄까지 스레드 동작을 늦출 수 있는 동기화 클래스이다.
- 래치는 단일 동작이 완료되기 이전에는 어떤 기능도 동작하지 않도록 막아내야 하는 경우 사용할 수 있다.
- CountDownLatch는 여러 스레드가 여러 이벤트가 알어날 때까지 대기할 수 있도록 한다.

### 5.5.2 FutureTask
- FutureTask는 시간이 많이 필요한 작업이 있을 때 실제 결과가 필요한 시점 이전에 미리 작업을 실행시켜두는 용도로 사용한다.
- Callable 인터페이스로 구현하도록 되어있다.
- Future.get() 메소드는 모든 예외를 ExecutionException으로 한 번 감싼 다음 throw한다.

### 5.5.3 세마포어
- 카운팅 세마포어(Counting Semaphore)는 특정 자원이나 특정 연산을 동시에 사용하거나 호출할 수 있는 스레드의 수를 제한하고자 할 때 사용한다.
- 자원 풀(Pool)이나 컬렉션의 크기를 제한할때 유용하다.로
- 세마포어는 가상의 퍼밋(Permit)을 만들어 퍼밋 수 만큼 요청할 수 있도록 상태를 관리한다.
    - acquire: 퍼밋이 확보될 때까지 대기
    - release: 퍼밋 반납
- 이진 세마포어는 초기 퍼밋 값을 1로 하는 세마포어이다. 이진 세마포어는 비재진입(NonReentrant) 락의 역할을 하는 뮤텍스(Mutex)로 활용할 수 있다.

### 5.5.4 배리어
- 배리어(Barrier)는 특정 이벤트가 발생할 때까지 여러 개의 스레드를 대기 상태로 잡아두고, 모든 스레드가 배리어 위치에 이르면 관문이 열리고 계속해서 실핼할 수 있다.
- 래치와의 차이점은 래치는 이벤트를 기다리는 동기화 클래스이고, 배리어는 다른 스레드를 기다리기 위한 동기화 클래스이다.
- CyclicBarrier 클래스를 사용하면 여러 스레드가 특정한 배리어 포인트에서 반복적으로 만나는 기능을 모델링할 수 있다.
- 배리어를 통해 처리중 타임아웃, 인터럽트 등이 발생하면 모든 스레드는 BrokenBarrierException이 발생한다.
- 배리어 작업은 Runnable 인터페이스를 구현한 클래스로 작성한다.
- Exchanger는 두 개의 스레드가 연결되는 배리어로, 배리어 포인트에 도달하면 두 스레드의 값을 교환한다.

## 5.6 효율적이고 확장성 있는 결과 캐시 구현
- 캐시를 사용하면 메모를 사용하여 대기 시간을 줄이면서 처리 용량을 늘릴 수 있다.
- 흔히 캐시 기능을 메모제이션(Memoization)이라고 한다.
